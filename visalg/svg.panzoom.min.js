

!function(svg_js) {
    "use strict";
    var normalizeEvent = function normalizeEvent(ev) {
        return ev.touches || [{
            clientX: ev.clientX,
            clientY: ev.clientY
        }]
    };
    svg_js.extend(svg_js.Svg, {
        panZoom: function panZoom(options) {
            var _options, _options$zoomFactor, _options$zoomMin, _options$zoomMax, _options$wheelZoom, _options$pinchZoom, _options$panning, _options$panButton, _options$oneFingerPan, _options$margins, _options$wheelZoomDel, _options$wheelZoomDel2, _this = this;
            if (this.off(".panZoom"),
            !1 === options)
                return this;
            var zoomFactor = null != (_options$zoomFactor = (options = null != (_options = options) ? _options : {}).zoomFactor) ? _options$zoomFactor : 2, zoomMin = null != (_options$zoomMin = options.zoomMin) ? _options$zoomMin : Number.MIN_VALUE, zoomMax = null != (_options$zoomMax = options.zoomMax) ? _options$zoomMax : Number.MAX_VALUE, doWheelZoom = null == (_options$wheelZoom = options.wheelZoom) || _options$wheelZoom, doPinchZoom = null == (_options$pinchZoom = options.pinchZoom) || _options$pinchZoom, doPanning = null == (_options$panning = options.panning) || _options$panning, panButton = null != (_options$panButton = options.panButton) ? _options$panButton : 0, oneFingerPan = null != (_options$oneFingerPan = options.oneFingerPan) && _options$oneFingerPan, margins = null != (_options$margins = options.margins) && _options$margins, wheelZoomDeltaModeLinePixels = null != (_options$wheelZoomDel = options.wheelZoomDeltaModeLinePixels) ? _options$wheelZoomDel : 17, wheelZoomDeltaModeScreenPixels = null != (_options$wheelZoomDel2 = options.wheelZoomDeltaModeScreenPixels) ? _options$wheelZoomDel2 : 53, lastP, lastTouches, zoomInProgress = !1, viewbox = this.viewbox(), restrictToMargins = function restrictToMargins(box) {
                if (!margins)
                    return box;
                var top = margins.top
                  , left = margins.left
                  , bottom = margins.bottom
                  , right = margins.right
                  , _this$attr = _this.attr(["width", "height"])
                  , width = _this$attr.width
                  , height = _this$attr.height
                  , preserveAspectRatio = _this.node.preserveAspectRatio.baseVal
                  , viewportLeftOffset = 0
                  , viewportRightOffset = 0
                  , viewportTopOffset = 0
                  , viewportBottomOffset = 0;
                if (preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE) {
                    var svgAspectRatio = width / height
                      , viewboxAspectRatio = viewbox.width / viewbox.height;
                    if (viewboxAspectRatio !== svgAspectRatio) {
                        var isMeet = preserveAspectRatio.meetOrSlice !== preserveAspectRatio.SVG_MEETORSLICE_SLICE
                          , changedAxis = svgAspectRatio > viewboxAspectRatio ? "width" : "height"
                          , isWidth = "width" === changedAxis
                          , changeHorizontal = isMeet && isWidth || !isMeet && !isWidth
                          , ratio = changeHorizontal ? svgAspectRatio / viewboxAspectRatio : viewboxAspectRatio / svgAspectRatio
                          , offset = box[changedAxis] - box[changedAxis] * ratio;
                        changeHorizontal ? preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX ? (viewportLeftOffset = offset / 2,
                        viewportRightOffset = -offset / 2) : preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX ? viewportRightOffset = -offset : preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN && preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID && preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX || (viewportLeftOffset = offset) : preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID ? (viewportTopOffset = offset / 2,
                        viewportBottomOffset = -offset / 2) : preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN ? viewportBottomOffset = -offset : preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX && preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX && preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX || (viewportTopOffset = offset)
                    }
                }
                var leftLimit = viewbox.width + viewbox.x - left - viewportLeftOffset
                  , rightLimit = viewbox.x + right - box.width - viewportRightOffset
                  , topLimit = viewbox.height + viewbox.y - top - viewportTopOffset
                  , bottomLimit = viewbox.y + bottom - box.height - viewportBottomOffset;
                return box.x = Math.min(leftLimit, Math.max(rightLimit, box.x)),
                box.y = Math.min(topLimit, Math.max(bottomLimit, box.y)),
                box
            }, wheelZoom = function wheelZoom(ev) {
                var normalizedPixelDeltaY;
                switch (ev.preventDefault(),
                ev.deltaMode) {
                case 1:
                    normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeLinePixels;
                    break;
                case 2:
                    normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeScreenPixels;
                    break;
                default:
                    normalizedPixelDeltaY = ev.deltaY
                }
                var lvl = Math.pow(1 + zoomFactor, -1 * normalizedPixelDeltaY / 100) * this.zoom()
                  , p = this.point(ev.clientX, ev.clientY);
                if (lvl > zoomMax && (lvl = zoomMax),
                lvl < zoomMin && (lvl = zoomMin),
                this.dispatch("zoom", {
                    level: lvl,
                    focus: p
                }).defaultPrevented)
                    return this;
                if (this.zoom(lvl, p),
                margins) {
                    var box = restrictToMargins(this.viewbox());
                    this.viewbox(box)
                }
            }, pinchZoomStart = function pinchZoomStart(ev) {
                (lastTouches = normalizeEvent(ev)).length < 2 ? doPanning && oneFingerPan && panStart.call(this, ev) : (doPanning && oneFingerPan && panStop.call(this, ev),
                ev.preventDefault(),
                this.dispatch("pinchZoomStart", {
                    event: ev
                }).defaultPrevented || (this.off("touchstart.panZoom", pinchZoomStart),
                zoomInProgress = !0,
                svg_js.on(document, "touchmove.panZoom", pinchZoom, this, {
                    passive: !1
                }),
                svg_js.on(document, "touchend.panZoom", pinchZoomStop, this, {
                    passive: !1
                })))
            }, pinchZoomStop = function pinchZoomStop(ev) {
                ev.preventDefault();
                var currentTouches = normalizeEvent(ev);
                currentTouches.length > 1 || (zoomInProgress = !1,
                this.dispatch("pinchZoomEnd", {
                    event: ev
                }),
                svg_js.off(document, "touchmove.panZoom", pinchZoom),
                svg_js.off(document, "touchend.panZoom", pinchZoomStop),
                this.on("touchstart.panZoom", pinchZoomStart),
                currentTouches.length && doPanning && oneFingerPan && panStart.call(this, ev))
            }, pinchZoom = function pinchZoom(ev) {
                ev.preventDefault();
                var currentTouches = normalizeEvent(ev), zoom = this.zoom(), lastDelta, currentDelta, zoomAmount = Math.sqrt(Math.pow(lastTouches[0].clientX - lastTouches[1].clientX, 2) + Math.pow(lastTouches[0].clientY - lastTouches[1].clientY, 2)) / Math.sqrt(Math.pow(currentTouches[0].clientX - currentTouches[1].clientX, 2) + Math.pow(currentTouches[0].clientY - currentTouches[1].clientY, 2));
                (zoom < zoomMin && zoomAmount > 1 || zoom > zoomMax && zoomAmount < 1) && (zoomAmount = 1);
                var currentFocus = {
                    x: currentTouches[0].clientX + .5 * (currentTouches[1].clientX - currentTouches[0].clientX),
                    y: currentTouches[0].clientY + .5 * (currentTouches[1].clientY - currentTouches[0].clientY)
                }
                  , lastFocus_x = lastTouches[0].clientX + .5 * (lastTouches[1].clientX - lastTouches[0].clientX)
                  , lastFocus_y = lastTouches[0].clientY + .5 * (lastTouches[1].clientY - lastTouches[0].clientY)
                  , p = this.point(currentFocus.x, currentFocus.y)
                  , focusP = this.point(2 * currentFocus.x - lastFocus_x, 2 * currentFocus.y - lastFocus_y)
                  , box = new svg_js.Box(this.viewbox()).transform((new svg_js.Matrix).translate(-focusP.x, -focusP.y).scale(zoomAmount, 0, 0).translate(p.x, p.y));
                restrictToMargins(box),
                this.viewbox(box),
                lastTouches = currentTouches,
                this.dispatch("zoom", {
                    box: box,
                    focus: focusP
                })
            }, panStart = function panStart(ev) {
                var isMouse;
                ev.type.indexOf("mouse") > -1 && ev.button !== panButton && ev.which !== panButton + 1 || (ev.preventDefault(),
                this.off("mousedown.panZoom", panStart),
                lastTouches = normalizeEvent(ev),
                zoomInProgress || (this.dispatch("panStart", {
                    event: ev
                }),
                lastP = {
                    x: lastTouches[0].clientX,
                    y: lastTouches[0].clientY
                },
                svg_js.on(document, "touchmove.panZoom mousemove.panZoom", panning, this, {
                    passive: !1
                }),
                svg_js.on(document, "touchend.panZoom mouseup.panZoom", panStop, this, {
                    passive: !1
                })))
            }, panStop = function panStop(ev) {
                ev.preventDefault(),
                svg_js.off(document, "touchmove.panZoom mousemove.panZoom", panning),
                svg_js.off(document, "touchend.panZoom mouseup.panZoom", panStop),
                this.on("mousedown.panZoom", panStart),
                this.dispatch("panEnd", {
                    event: ev
                })
            }, panning = function panning(ev) {
                ev.preventDefault();
                var currentTouches = normalizeEvent(ev)
                  , currentP = {
                    x: currentTouches[0].clientX,
                    y: currentTouches[0].clientY
                }
                  , p1 = this.point(currentP.x, currentP.y)
                  , p2 = this.point(lastP.x, lastP.y)
                  , deltaP = [p2.x - p1.x, p2.y - p1.y];
                if (deltaP[0] || deltaP[1]) {
                    var box = new svg_js.Box(this.viewbox()).transform((new svg_js.Matrix).translate(deltaP[0], deltaP[1]));
                    lastP = currentP,
                    restrictToMargins(box),
                    this.dispatch("panning", {
                        box: box,
                        event: ev
                    }).defaultPrevented || this.viewbox(box)
                }
            };
            return doWheelZoom && this.on("wheel.panZoom", wheelZoom, this, {
                passive: !1
            }),
            doPinchZoom && this.on("touchstart.panZoom", pinchZoomStart, this, {
                passive: !1
            }),
            doPanning && this.on("mousedown.panZoom", panStart, this, {
                passive: !1
            }),
            this
        }
    })
}(SVG);
